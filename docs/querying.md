# Querying

Both [DB](https://pkg.go.dev/github.com/rfberaldo/sqlz#DB) and [Tx](https://pkg.go.dev/github.com/rfberaldo/sqlz#Tx) have these three methods:

```go
Query(ctx context.Context, query string, args ...any) *Scanner
QueryRow(ctx context.Context, query string, args ...any) *Scanner
Exec(ctx context.Context, query string, args ...any) (sql.Result, error)
```

## Query

Query from database and returns a [Scanner](https://pkg.go.dev/github.com/rfberaldo/sqlz#Scanner) object that automatically scans all rows.
Errors are deferred to scanner for easy chaining, until `Err()` or `Scan()` is called.


Simple query with automatic scan into a struct slice:

```go
var users []User
db.Query(ctx, "SELECT * FROM user").Scan(&name)
// users variable now contains data from query
```

Auto expanding **"IN"** clauses out of the box:

```go
args := []int{4, 8, 16}
var users []*User
db.Query(ctx, "SELECT * FROM user WHERE id IN (?)", args).Scan(&users)
// executed as "SELECT * FROM user WHERE id IN (?,?,?)"
```

## QueryRow

Query from database and returns a [Scanner](https://pkg.go.dev/github.com/rfberaldo/sqlz#Scanner) object that automatically scans at maximum one row.
Errors are deferred to scanner for easy chaining, until `Err()` or `Scan()` is called.
If query result is empty, scanner returns [sql.ErrNoRows](https://pkg.go.dev/database/sql#ErrNoRows):

```go
var user User
err = db.QueryRow(ctx, "SELECT * FROM user WHERE id = ?", 42).Scan(&user)
if err != nil {
  if sqlz.IsNotFound(err) {
    log.Fatal("user not found!")
  }
  log.Fatal(err)
}
```

> [!TIP]
> `IsNotFound` is a helper function to check for `sql.ErrNoRows` using [errors.Is](https://pkg.go.dev/errors#Is), although sqlz does not decorate the error.

## Exec

Exec is very similar to standard library, it returns the same [sql.Result](https://pkg.go.dev/database/sql#Result) object, which have two methods:
- `LastInsertId()`: returns the integer generated by the database from an auto-increment column when inserting a new row. Not all databases support this feature.
In MySQL it works as expected, but in PostgreSQL this information is only available by using the **"RETURNING"** clause in a query.
- `RowsAffected()`: returns the number of rows affected by an update, insert, or delete. Not every database or driver support this feature.

```go
result, err := db.Exec(ctx, "INSERT INTO user (name) VALUES (?)", "Alice")
id, err := result.LastInsertId()
```

### Note about placeholders

It is a good practice to always use placeholders to send parameters to the database, as they will prevent [SQL injection](https://en.wikipedia.org/wiki/SQL_injection) attacks.
On databases/drivers that support, the query is prepared on the server first before execution.

Placeholder syntax is database specific:

- MySQL uses the `?` variant shown above
- PostgreSQL uses an enumerated `$1`, `$2`, etc.
- SQL Server uses an enumerated `@p1`, `@p2`, etc.
- SQLite accepts both `?` and `$1` syntax
- Oracle uses a `:name` syntax

All the above syntaxes are supported by **sqlz**.

> [!NOTE]
> Placeholders are only used for parameterization, and are not allowed to change the structure of an SQL statement. For instance, a placeholder won't be able to change the table or field name from a **"SELECT"** statement.

When querying using placeholders, all parameters must have their correct position based on the order they appear on query, just like [fmt.Sprintf](https://pkg.go.dev/fmt#Sprintf).

## Named queries

Passing `struct` or `map[string]any` as argument makes **sqlz** to parse it as as a **named query**.
Named queries are easier to work with, because you don't need to refer to parameters positionally.
It will replace the `:param` syntax with the driver's placeholder, and rearrange the arguments, meaning it works independently of the driver.

```go
loc := Location{Country: "Brazil"}
var users []User
db.Query(ctx, "SELECT * FROM user WHERE country = :country", loc).Scan(&users)
```

Passing a slice of structs or maps works as a batch insert, it expands the insert syntax:

```go
users := []User{
  {Name: "Alice", Email: "alice@example.com"},
  {Name: "Rob", Email: "rob@example.com"},
  {Name: "John", Email: "john@example.com"},
}
db.Exec(ctx, "INSERT INTO user (name, email) VALUES (:name, :email)", users)
// executed as "INSERT INTO user (name, email) VALUES (?, ?), (?, ?), (?, ?)"
```

To access nested fields from a struct or map, use dot notation:

```go
order := Order{
  Store: Store{Id: 42},
  Customer: Customer{Id: 69},
}

var orders []Order
db.Query(
  ctx, `
  SELECT * FROM order
  WHERE store_id = :store.id
    AND customer_id = :customer.id`,
  order,
).Scan(&orders)
```

> [!TIP]
> Named struct queries follows the same rules from [Struct scanning](/scanning#struct-scanning).

## Context parameter

In case you're wondering why each query method has a [context.Context](https://pkg.go.dev/context#Context) as first parameter;
It is [strongly recommended](https://go.dev/blog/context) to always use context when working with I/O operations. For example, if you're developing a web server, pass the context from the request to these methods; this will ensure that all DB connections bound to that request are closed in cascade if the client closes the connection. It also makes it easier to add deadlines or timeouts to any query.
